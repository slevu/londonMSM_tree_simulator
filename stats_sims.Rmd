---
title: "Analyze simulations cluster size and outdegrees"
author: "Stephane"
date: "23 May 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=FALSE)
```

Load tables
```{r}
##- Load data
cw_Baseline0 <- readRDS(file = "data/sim_ucsd_results2/list.sim.clus-outdeg.Baseline0.rds" )
# cw_EqualStage0 <- readRDS(file = "data/sim_ucsd_results2/list.sim.clus-outdeg.EqualStage0.rds" )
```

## 0. Plot cluster size and outdegree
```{r}
##- calculate individual mean size and outdegree over sims
 ## change structure (first few for speed)
    a <- lapply(cw_Baseline0, function(x) do.call(rbind, x[1:10]))
    str(a)
    ## mean by id of set of variables var
    mean.sims <- lapply(a, function(df) {
      aggregate(df[, c("binclus", "size", "outdegree", "indegree")],
                           list("id" = df$id, 
                                "stage" = df$stage,
                                "age" = df$age,
                                "risk" = df$risk),                                                               function(x) mean(x, na.rm = TRUE) )
    })
    ##- full table
    par(mfrow = c(length(a), 2), bty = 'n')
    for (i in 1:length(a)){
      hist(a[[i]]$size, main = names(a)[i], xlab = "cluster size")
      plot(a[[i]]$size, a[[i]]$outdegree,
           xlab = "cluster size",
           ylab = "out-degree",
           col="#00000050", 
           main = names(a)[i])
    }
    dev.off()
    ##- correlation
    cor(a[[1]]$size, a[[1]]$outdegree, use = "complete")
    cor(a[[2]]$size, a[[2]]$outdegree, use = "complete")
    

    par(mfrow = c(1, 2), bty = 'n')
      hist(a[[1]]$outdegree, main = "", xlab = "out-degree")
      hist(a[[1]]$indegree, main = "", xlab =  "in-degree")
     
    dev.off()
    
     ##- mean
    str(mean.sims)
    b <- mean.sims
    
    par(mfrow = c(length(b), 2), bty = 'n')
    for (i in 1:length(b)){
      hist(b[[i]]$size, main = names(b)[i], xlab = "cluster size")
      plot(b[[i]]$size, b[[i]]$outdegree,
           xlab = "cluster size",
           ylab = "out-degree",
           col="#00000050", 
           main = names(b)[i])
    }
    dev.off()

```
* Cluster sizes and outdegrees have weak correlation

## 1. Detect difference in transmission rate by risk level
### 1.1 Univariate
```{r}
##- U tests on size or outdegree
u.test.risk <- function(df, y){
  U <- wilcox.test(df[df$risk == 2, y], 
                   df[df$risk == 1, y], 
                   alternative = "greater") # "two.sided", "less"
  return(U$p.value)
}

##- p-values for test of cluster size in risk 2 vs risk 1
p_cs <- lapply(cw_Baseline0, function (x)  {
  sapply(x, function(df) u.test.risk(df, y = "size") )
 } )
##- Add p-values for outdegree testing
p_sa <- sapply(cw_Baseline0[[1]], function(df) u.test.risk(df, y = "outdegree") )
p_uni <- c(p_cs, "SA"= list(p_sa) )

##- stats of p-values
sapply(p_uni, summary)

##- table of proportion p-values < 0.05
tab <- data.frame("method" = c(paste("Cluster", names(cw_Baseline0)), "SA"),
                 "proportion univariate" = sapply(p_uni, function(x) mean( x < 0.05)),
                 row.names = NULL)

```


### 1.2 Multivariate
```{r}
##- lm model adjusting for stage of infection
# y = "outdegree"
lm.risk <- function(df, y){
  model0 <- "scale(log(y)) ~ scale(risk) * as.factor(stage)"
  model <- sub("y", y, model0)
  ##- pvalue for risk parameter
  p <- coef(summary( lm( model , data = df) ))[2, 4]
  return(p)
}
p_mult_cs <- lapply(cw_Baseline0, function (x)  {
  sapply(x, function(df) lm.risk(df, y = "size") )
 } )
p_mult_sa <- sapply(cw_Baseline0[[1]], function(df) lm.risk(df, y = "outdegree") )
p_mult <- c(p_mult_cs, "SA"= list(p_mult_sa) )
sapply(p_mult, summary)

tab <- cbind(tab, "proportion multivariate" = sapply(p_mult, function(x) mean( x < 0.05)))
row.names(tab) <- NULL
```

#### Proportion of tests correctly detecting difference in transmission rates
```{r, results='asis'}
knitr::kable(tab)
```

* Note: restricting to outdegrees > 0 doesn't change anything (there are no zero values ?)
* Interpretation: need to test scenario with different levels of difference in transmission rates

```{r}
##- into a dataframe for ggplot boxplot or violinplot
cc <- matrix(sapply(p_uni, c), ncol = 5)
colnames(cc) <- names(p_uni)
head(cc)
d <- as.data.frame.table(cc)
head(d)
str(d)
### laaaaaaaaaaa------------------------------------------------------
library(ggplot2)
ggplot(d[d$Var2 != "SA",], aes(x = Var2, y = Freq, fill = Var2)) + geom_violin()
```



## Associations
## Type 1 / 2 error: detect a difference in risk, age, stage ?
## Regressions
## Assortativity
    1. Calculate mixing matrix
    2. Calculate true assortativity coefficient
    3. Compare with estimated coefficient
## Plots
    1. Distribution cluster sizes, out- and indegrees
    2. Network
  
## Next: change scenarios
  * high, low, no age assortativity
  * high, low, no at-risk group




You can also embed plots, for example:

```{r, echo=FALSE}
plot(cars)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
